# [LeetCode]-0011 盛最多水的容器

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

说明：你不能倾斜容器。

* **示例 1**：

![img.png](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

> **输入**：[1, 8, 6, 2, 5, 4, 8, 3, 7]
> 
> **输出**：49
> 
> **解释**：图中垂直线代表输入数组 [1, 8, 6, 2, 5, 4, 8, 3, 7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

* **示例 2**：
> **输入**：height = [1, 1]
> 
> **输出**：1

* **提示**：
  * `n == height.length`
  * `2 <= n <= 105`
  * `0 <= height[i] <= 104`

## 双指针
设两指针 `i` ，`j`，指向的水槽板高度分别为 `h[i]` ，`h[j]`，此状态下水槽面积为 `S(i, j)` 。由于可容纳水的高度由两板中的 **短板** 决定，因此可得如下面积公式 ：
$$
S(i, j) = min(h[i], h[j]) × (j−i)
$$
![img](https://pic.leetcode-cn.com/1628780627-VtSmcP-Picture0.png)

在每个状态下，无论长板或短板向中间收窄一格，都会导致水槽 **底边宽度 − 1** 变短：

* 若向内 **移动短板** ，水槽的短板 `min(h[i], h[j])`可能变大，因此下个水槽的面积 **可能增大** 。
* 若向内 **移动长板** ，水槽的短板 `min(h[i], h[j])` 不变或变小，因此下个水槽的面积 **一定变小** 。

因此，初始化双指针分列水槽左右两端，循环每轮将短板向内移动一格，并更新面积最大值，直到两指针相遇时跳出；即可获得最大面积。

**算法流程：**

1. **初始化**：双指针 `i` ，`j` 分列水槽左右两端；
2. **循环收窄**：直至双指针相遇时跳出；
   * 更新面积最大值 `res`；
   * 选定两板高度中的短板，向中间收窄一格；
3. **返回值**： 返回面积最大值 `res` 即可；

**正确性证明：**

若暴力枚举，水槽两板围成面积 `S(i, j)` 的状态总数为 `C(n, 2)`。

假设状态 `S(i, j)` 下`h[i] < h[j]` ，在向内移动短板至 `S(i+1, j)`，则相当于消去了 `S(i, j−1), S(i, j−2), ..., S(i, i+1)` 状态集合。而所有消去状态的面积一定都小于当前面积（即 `< S(i, j)`），因为这些状态：

* 短板高度：相比 `S(i, j)` 相同或更短（即 `≤ h[i]`）；
* 底边宽度：相比 `S(i, j)` 更短；

因此，每轮向内移动短板，所有消去的状态都 **不会导致面积最大值丢失** ，证毕。
```java
public int maxArea(int[] height) {
    int head = 0, tail = height.length - 1, maxArea = 0;
    while (head < tail) {
        int area = 0;
        if (height[head] > height[tail]) {
            area = height[tail] * (tail - head);
            tail--;
        } else {
            area = height[head] * (tail - head);
            head++;
        }
        maxArea = Math.max(maxArea, area);
    }
    return maxArea;
}
```